// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// -------- //
// maple_in //
// -------- //

#define maple_in_wrap_target 13
#define maple_in_wrap 28

static const uint16_t maple_in_program_instructions[] = {
	0xa04b,
	//  0: mov    y, !null                   
	0x00c8,
	//  1: jmp    pin, 8                     
	0xa0e0,
	//  2: mov    osr, pins                  
	0x6022,
	//  3: out    x, 2                       
	0x0041,
	//  4: jmp    x--, 1                     
	0x20a1,
	//  5: wait   1 pin, 1                   
	0x00c0,
	//  6: jmp    pin, 0                     
	0x0081,
	//  7: jmp    y--, 1                     
	0xa04a,
	//  8: mov    y, !y                      
	0xe024,
	//  9: set    x, 4                       
	0x00a0,
	// 10: jmp    x != y, 0                  
	0xc010,
	// 11: irq    nowait 0 rel               
	0x2020,
	// 12: wait   0 pin, 0                   
	        //     .wrap_target
	    0xe041,
	// 13: set    y, 1                       
	    0xa0e0,
	// 14: mov    osr, pins                  
	    0x6021,
	// 15: out    x, 1                       
	    0x0038,
	// 16: jmp    !x, 24                     
	    0x6021,
	// 17: out    x, 1                       
	    0x0075,
	// 18: jmp    !y, 21                     
	    0x002e,
	// 19: jmp    !x, 14                     
	    0x008e,
	// 20: jmp    y--, 14                    
	    0x004e,
	// 21: jmp    x--, 14                    
	    0x4078,
	// 22: in     null, 24                   
	    0xc030,
	// 23: irq    wait 0 rel                 
	    0x40e1,
	// 24: in     osr, 1                     
	    0x20a1,
	// 25: wait   1 pin, 1                   
	    0x2021,
	// 26: wait   0 pin, 1                   
	    0x4001,
	// 27: in     pins, 1                    
	    0x20a0,
	// 28: wait   1 pin, 0                   
	            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program maple_in_program = {
	.instructions = maple_in_program_instructions,
	.length = 29,
	.origin = -1,
};

static inline pio_sm_config maple_in_program_get_default_config(uint offset) {
	pio_sm_config c = pio_get_default_sm_config();
	sm_config_set_wrap(&c, offset + maple_in_wrap_target, offset + maple_in_wrap);
	return c;
}

#include "hardware/gpio.h"
#include "hardware/pio.h"
#include "PioProgram.hpp"
#define MAPLE_IN_PIO pio1
class MapleInStateMachine
{
public:
	inline MapleInStateMachine(uint pin_a)
		: mProgram(getMapleInProgram())
		, mPinA(pin_a)
		, mPinB(pin_a + 1)
		, mMaskAB(3 << pin_a)
		, mSmIdx(pio_claim_unused_sm(mProgram.mPio, true))
		, mPrestarted(false)
	{
		// Initialize the two pins as inputs with pullups
		gpio_set_dir_in_masked(mMaskAB);
		gpio_set_pulls(mPinA, true, false);
		gpio_set_pulls(mPinB, true, false);
		pio_sm_config c = maple_in_program_get_default_config(mProgram.mProgramOffset);
		sm_config_set_in_pins(&c, mPinA);
		// jmp pin checks pin A
		sm_config_set_jmp_pin(&c, mPinA);
		// Shift to right, autopull disabled, 32 bits at a time
		sm_config_set_out_shift(&c, true, false, 32);
		// Shift to left, autopush enabled, 32 bits at a time
		sm_config_set_in_shift(&c, false, true, 32);
		// Sample as fast as possible
		sm_config_set_clkdiv(&c, 1);
		// Load our configuration, and jump to the start of the program
		pio_sm_init(mProgram.mPio, mSmIdx, mProgram.mProgramOffset, &c);
	}
	inline void prestart()
	{
		// Reset pointers
		pio_sm_clear_fifos(mProgram.mPio, mSmIdx);
		pio_sm_restart(mProgram.mPio, mSmIdx);
		pio_sm_clkdiv_restart(mProgram.mPio, mSmIdx);
		pio_sm_exec(mProgram.mPio, mSmIdx, pio_encode_jmp(mProgram.mProgramOffset));
		// Pin direction starts as input
		pio_sm_set_consecutive_pindirs(mProgram.mPio, mSmIdx, mPinA, 2, false);
		mPrestarted = true;
	}
	inline void start()
	{
		if (!mPrestarted)
		{
			prestart();
		}
		mPrestarted = false;
		// Set this pin's GPIO function (connect PIO to the pad)
		pio_gpio_init(mProgram.mPio, mPinA);
		pio_gpio_init(mProgram.mPio, mPinB);
		// Set the state machine running
		pio_sm_set_enabled(mProgram.mPio, mSmIdx, true);
	}
	inline void stop() const
	{
		pio_sm_set_enabled(mProgram.mPio, mSmIdx, false);
		// Reset the pins' function to standard I/O with pullups
		gpio_set_dir_in_masked(mMaskAB);
		gpio_set_function(mPinA, GPIO_FUNC_SIO);
		gpio_set_function(mPinB, GPIO_FUNC_SIO);
	}
private:
	inline static const PioProgram& getMapleInProgram()
	{
		static const PioProgram program(MAPLE_IN_PIO, &maple_in_program);
		return program;
	}
public:
	const PioProgram& mProgram;
	const uint mPinA;
	const uint mPinB;
	const uint mMaskAB;
	const uint mSmIdx;
	bool mPrestarted;
};

#endif

