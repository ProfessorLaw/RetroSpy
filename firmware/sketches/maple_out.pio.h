// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#include <hardware/pio.h>

// --------- //
// maple_out //
// --------- //

#define maple_out_wrap_target 22
#define maple_out_wrap 19

#define maple_out_MASK_A 1
#define maple_out_MASK_B 2
#define maple_out_MASK_AB 3
#define maple_out_DOUBLE_PHASE_TICKS 4
#define maple_out_SINGLE_PHASE_TICKS 2

static const uint16_t maple_out_program_instructions[] = {
	0x7c20,
	//  0: out    x, 32           side 3     
	0xff83,
	//  1: set    pindirs, 3      side 3 [3] 
	0xfb43,
	//  2: set    y, 3            side 2 [3] 
	0xb342,
	//  3: nop                    side 0 [3] 
	0xba42,
	//  4: nop                    side 2 [2] 
	0x0083,
	//  5: jmp    y--, 3                     
	0x1c47,
	//  6: jmp    x--, 7          side 3     
	0x7c41,
	//  7: out    y, 1            side 3     
	0x1c6e,
	//  8: jmp    !y, 14          side 3     
	0x1c0d,
	//  9: jmp    13              side 3     
	0x7441,
	// 10: out    y, 1            side 1     
	0x006e,
	// 11: jmp    !y, 14                     
	0xbd42,
	// 12: nop                    side 3 [1] 
	0x1950,
	// 13: jmp    x--, 16         side 2 [1] 
	0xb542,
	// 14: nop                    side 1 [1] 
	0x1150,
	// 15: jmp    x--, 16         side 0 [1] 
	0x7841,
	// 16: out    y, 1            side 2     
	0x0074,
	// 17: jmp    !y, 20                     
	0xbd42,
	// 18: nop                    side 3 [1] 
	0x154a,
	// 19: jmp    x--, 10         side 1 [1] 
	        //     .wrap
	    0xb942,
	// 20: nop                    side 2 [1] 
	    0x114a,
	// 21: jmp    x--, 10         side 0 [1] 
	            //     .wrap_target
	        0x7558,
	// 22: out    y, 24           side 1 [1] 
	        0xbf42,
	// 23: nop                    side 3 [3] 
	        0xb742,
	// 24: nop                    side 1 [3] 
	        0xb342,
	// 25: nop                    side 0 [3] 
	        0xb742,
	// 26: nop                    side 1 [3] 
	        0xb342,
	// 27: nop                    side 0 [3] 
	        0xd430,
	// 28: irq    wait 0 rel      side 1     
};

#if !PICO_NO_HARDWARE
static const struct pio_program maple_out_program = {
	.instructions = maple_out_program_instructions,
	.length = 29,
	.origin = -1,
};

static inline pio_sm_config maple_out_program_get_default_config(uint offset) {
	pio_sm_config c = pio_get_default_sm_config();
	sm_config_set_wrap(&c, offset + maple_out_wrap_target, offset + maple_out_wrap);
	sm_config_set_sideset(&c, 3, true, false);
	return c;
}

#include "hardware/gpio.h"
#include "hardware/pio.h"
#include "PioProgram.hpp"
#define MAPLE_OUT_PIO pio0
class MapleOutStateMachine
{
public:
	inline MapleOutStateMachine(uint sys_freq_khz, uint ns_per_bit, uint pin_a)
		: mProgram(getMapleOutProgram())
		, mPinA(pin_a)
		, mPinB(pin_a + 1)
		, mMaskAB(3 << pin_a)
		, mSmIdx(pio_claim_unused_sm(mProgram.mPio, true))
	{
		// Initialize the two pins as inputs with pullups
		gpio_set_dir_in_masked(mMaskAB);
		gpio_set_pulls(mPinA, true, false);
		gpio_set_pulls(mPinB, true, false);
		pio_sm_config c = maple_out_program_get_default_config(mProgram.mProgramOffset);
		sm_config_set_sideset_pins(&c, mPinA);
		sm_config_set_set_pins(&c, mPinA, 2); // just for set pindirs
		// Shift to left, autopull enabled, 32 bits at a time
		sm_config_set_out_shift(&c, false, true, 32);
		sm_config_set_clkdiv(
		    &c,
			(sys_freq_khz * (ns_per_bit / 3 * 2)) / maple_out_DOUBLE_PHASE_TICKS / 1000000.0);
		// Load our configuration, and jump to the start of the program
		pio_sm_init(mProgram.mPio, mSmIdx, mProgram.mProgramOffset, &c);
	}
	inline void start() const
	{
		// Reset pointers
		pio_sm_clear_fifos(mProgram.mPio, mSmIdx);
		pio_sm_restart(mProgram.mPio, mSmIdx);
		pio_sm_clkdiv_restart(mProgram.mPio, mSmIdx);
		pio_sm_exec(mProgram.mPio, mSmIdx, pio_encode_jmp(mProgram.mProgramOffset));
		// Pin direction starts as input
		pio_sm_set_consecutive_pindirs(mProgram.mPio, mSmIdx, mPinA, 2, false);
		// Set this pin's GPIO function (connect PIO to the pad)
		pio_gpio_init(mProgram.mPio, mPinA);
		pio_gpio_init(mProgram.mPio, mPinB);
		// Set the state machine running
		pio_sm_set_enabled(mProgram.mPio, mSmIdx, true);
	}
	inline void stop(bool hardstop) const
	{
		pio_sm_set_enabled(mProgram.mPio, mSmIdx, false);
		if (hardstop)
		{
			// Reset the pins' function to standard I/O, transitioning back HIGH before setting to input
			gpio_set_mask(mMaskAB);
			gpio_set_dir_out_masked(mMaskAB);
		}
		else
		{
			// Allow pull-up to continue to keep B low
			gpio_set_pulls(mPinB, false, true);
		}
		gpio_set_dir_in_masked(mMaskAB);
		gpio_set_function(mPinB, GPIO_FUNC_SIO);
		gpio_set_function(mPinA, GPIO_FUNC_SIO);
	}
	inline static const PioProgram& getMapleOutProgram()
	{
		static const PioProgram program(MAPLE_OUT_PIO, &maple_out_program);
		return program;
	}
public:
	const PioProgram& mProgram;
	const uint mPinA;
	const uint mPinB;
	const uint mMaskAB;
	const uint mSmIdx;
};

#endif

